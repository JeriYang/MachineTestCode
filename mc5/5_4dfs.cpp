/*
题目背景
给定一个N\*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。
题目描述
输入输出格式
输入格式

第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点坐标FX,FY。接下来T行，每行为障碍点的坐标。
输出格式

给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方案总数。
输入输出样例
输入样例 #1
2 2 1
1 1 2 2
1 2
输出样例 #1
1
说明
【数据规模】 1≤N,M≤5

这题牛客网没有，就去网上找的

1≤N,M≤5
题目整体来说比较简单，思路就是使用深搜一个一个查，用两个数组分别标记走过的点和障碍物，使用自动选择方向来简化代码，没有遇到障碍物并且不是自己走过的就进一步搜索，把自己走过的路打上标记，返回时，再将标记还原。
具体细节在代码里注释有
————————————————
版权声明：本文为CSDN博主「wlis」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_43916464/article/details/96154030
*/

#include<bits/stdc++.h> //万能头文件
using namespace std;
int maps[10][10];  //标记迷宫障碍 
int visit[10][10];  //标记已经访问过的点 
int d[4][2]={{-1,0},{1,0},{0,-1},{0,1}};  //上下左右四种移动方式（根据题目不同可改变，有的题目是两种移动方式，用二维数组即可）
int sx,sy,fx,fy; //起点和终点的坐标 
int N,M;  //N行M列 
int num=0; //记录方案数 

//深搜
void dfs(int x,int y) //横坐标和竖坐标
{
  if(x==fx&&y==fy) //到达终点了
  {
  	num++;
	return; 
  }
  else{
  	for(int i=0;i<4;i++){
  		//记录新的坐标 
  		int a=x+d[i][0];
  		int b=y+d[i][1];
  		if(a<1||a>N||b<1||b>M) //越界处理 
  		continue;
  		if(visit[a][b]==1) //避免重复
		 continue;
		 if(maps[a][b]==1) //碰到障碍物了
		 continue;
		 visit[a][b]=1; //标记走过的点
		 dfs(a,b);
		 visit[a][b]=0; //回溯（这步很重要，恢复原来的标记） 
		 
	  }
  }
	  
} 

int main(){
	int T,l,r; //障碍物总数和坐标 
	//初始化 
	memset(maps,0,sizeof(maps));
	memset(visit,0,sizeof(visit)); 
	cin>>N>>M>>T;
	cin>>sx>>sy>>fx>>fy;
	for(int i=0;i<T;i++){
		cin>>l>>r;
		maps[l][r]=1; //为障碍物打上标记 
	}
	visit[sx][sy]=1; //为起点打访问标记
	dfs(sx,sy);
	cout<<num; 
	return 0;
} 

