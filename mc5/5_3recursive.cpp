/*
约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到右边的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。
现在我们改变游戏的玩法，不允许直接从最左(右)边移到最右(左)边(每次移动一定是移到中间杆或从中间移出)，也不允许大盘放到下盘的上面。
Daisy已经做过原来的汉诺塔问题和汉诺塔II，但碰到这个问题时，她想了很久都不能解决，现在请你帮助她。现在有N个圆盘，她至少多少次移动才能把这些圆盘从最左边移到最右边？

Input包含多组数据，每次输入一个N值(1<=N=35)。Output对于每组数据，输出移动最小的次数。
Sample Input
1
3
12

Sample Output
2
26
531440
————————————————

思路：这个题是一个典型的递归问题。三根柱子，不允许从最左边直接移到最右端，
那么思考，先将n-1个圆盘经过B移到C，需要f[n-1]种方法，再把最大的移到B，
再把C上的n-1个圆盘通过B移到A需要f[n-1]步，再把最大的移到C，
再把n-1个圆盘从A移到C，所以f[n]=3*f[n-1]+2,代码如下:

按格式输入->寻找递归方法并调用->按格式输出

@author:JeriYang
@time:2019

*/

#include <stdio.h>
#include <stdlib.h>
int main()
{
    int i,n;
    long long ans[40];
    while(~scanf("%d",&n))
    {
        ans[1]=2;
        for(i=2;i<=35;i++)
        {
            ans[i]=3*ans[i-1]+2;
        }
        printf("%I64d\n",ans[n]);
    }
    return 0;
}