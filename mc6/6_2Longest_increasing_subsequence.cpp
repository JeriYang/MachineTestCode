/*
LIS
题目描述
某国为了防御敌国的导弹袭击，开发出一种导弹拦截系统。
但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。
某天，雷达捕捉到敌国的导弹来袭，并观测到导弹依次飞来的高度，请计算这套系统最多能拦截多少导弹。
拦截来袭导弹时，必须按来袭导弹袭击的时间顺序，不允许先拦截后面的导弹，再拦截前面的导弹。 

输入描述:
每组输入有两行，
第一行，输入雷达捕捉到的敌国导弹的数量k（k<=25），
第二行，输入k个正整数，表示k枚导弹的高度，按来袭导弹的袭击时间顺序给出，以空格分隔。

输出描述:
每组输出只有一行，包含一个整数，表示最多能拦截多少枚导弹。

示例1
输入
8
300 207 155 300 299 170 158 65

输出
6

思路：
按格式输入->找DP方程->按格式输出
dp[1]=1
dp[i]=max{1,F[j]|j<i&&aj>=ai}

@author:JeriYang
@time:2019

*/

#include<stdio.h>
 
int main()
{
    int k,i,j,max;
    while(scanf("%d",&k)!=EOF)
    {
        int d[26]={0},num[26]={0,1};
        for(i=1;i<=k;i++)
            scanf("%d",&d[i]);
        max=1;                      /*max表示最多拦截的导弹数*/
        for(i=2;i<=k;i++)
        {
            num[i]=1;                /*以d[i]结尾的子列长度最短为1*/
            for(j=i-1;j>=0;j--)     /*从d[i-1]开始向前寻找值小于d[i]的数的d[k]，则num[i]=max{num[i],num[j]+1}*/
               if(d[j]>=d[i])
                    num[i]=(num[j]+1>num[i])?num[j]+1:num[i];   /*num[i]不能换成1，因为在向前循环时num[i]可能大于1*/
            max=max>num[i]?max:num[i];/*寻找最长子列*/
        }
        printf("%d\n",max);
    }
    return 0;
}